<?php

/**
 * @file
 * Commerce Adyen.
 */

/**
 * Name of payment method.
 */
define('COMMERCE_ADYEN_PAYMENT_METHOD', 'commerce_adyen');
/**
 * Name of instances of payment method.
 */
define('COMMERCE_ADYEN_PAYMENT_METHOD_INSTANCE', sprintf('%s|commerce_payment_%1$s', COMMERCE_ADYEN_PAYMENT_METHOD));
/**
 * Remote status of a payment. Money has been captured.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_CAPTURED', 'captured');
/**
 * Remote status of a payment. Payment authorised on Adyen side.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_AUTHORISED', 'authorised');
/**
 * Remote status of a payment. Payment pending on Adyen side.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_PENDING', 'pending');
/**
 * Remote status of a payment. Payment failure on Adyen side.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_FAILURE', 'failure');

use Commerce\Adyen\Payment\Capture;
use Commerce\Adyen\Payment\Controller\Payment;
use Commerce\Adyen\Payment\Controller\Checkout;

/**
 * Get payment type definitions.
 *
 * @return array[]
 *   Payment type definitions.
 *
 * @see hook_commerce_adyen_payment_types()
 */
function commerce_adyen_payment_types() {
  return service_collector(__FUNCTION__, function ($type, array $payment_type) {
    if (empty($payment_type['label'])) {
      throw new \InvalidArgumentException(t('Adyen payment type definition must have a label.'));
    }

    if (!isset($payment_type['controllers']['payment'])) {
      throw new \InvalidArgumentException(t('Adyen payment type must have definition of payment controller.'));
    }

    if (!is_subclass_of($payment_type['controllers']['payment'], Payment::class)) {
      throw new \InvalidArgumentException(t('Adyen payment type controller must be inherited from %class.', [
        '%class' => Payment::class,
      ]));
    }

    if (isset($payment_type['controllers']['checkout']) && !is_subclass_of($payment_type['controllers']['checkout'], Checkout::class)) {
      throw new \InvalidArgumentException(t('Adyen payment checkout controller must be inherited from %class.', [
        '%class' => Checkout::class,
      ]));
    }
  });
}

/**
 * Get an instance of transaction.
 *
 * @param string $type
 *   One of transaction types.
 * @param \stdClass|int|string $order
 *   Commerce order object or order ID.
 * @param string $remote_status
 *   Will be used as condition for loading existing transaction.
 *
 * @return \Commerce\Adyen\Payment\Transaction\Payment|\Commerce\Adyen\Payment\Transaction\Refund
 *   An instance of transaction object.
 */
function commerce_adyen_get_transaction_instance($type, $order, $remote_status = '') {
  return commerce_utils_get_transaction_instance(COMMERCE_ADYEN_PAYMENT_METHOD, $type, $order, $remote_status);
}

/**
 * Payment capture request.
 *
 * @param \stdClass $order
 *   An instance of "commerce_order" entity.
 *
 * @see commerce_adyen_rules_action_info()
 */
function commerce_adyen_capture_request(\stdClass $order) {
  $flag = COMMERCE_ADYEN_PAYMENT_METHOD . '_capture_sent';

  try {
    if (!isset($order->order_id, $order->order_number)) {
      throw new \InvalidArgumentException(t('An argument is not a valid object of the "@entity_type" entity.', [
        '@entity_type' => 'commerce_order',
      ]));
    }

    if (empty($order->data[$flag])) {
      $capture = new Capture($order);
      $options = ['%order_number' => $order->order_number];

      if ($capture->isAvailable()) {
        if ($capture->request()) {
          // Mark that we don't need to resend the capture
          // request once we successfully did this.
          $order->data[$flag] = TRUE;
          // Save the order.
          commerce_order_save($order);
        }
        else {
          throw new \RuntimeException(t('Capture request for the %order_number order was rejected by Adyen.', $options));
        }
      }
      else {
        throw new \RuntimeException(t('Capture request cannot be performed for the %order_number order because it have no authorised Adyen transactions.', $options));
      }
    }
  }
  catch (\Exception $e) {
    watchdog_exception(COMMERCE_ADYEN_PAYMENT_METHOD, $e);
  }
}

/**
 * Process an amount due to strange behavior regarding some currencies.
 *
 * This function must be called for every price amount and all logic
 * for processing currencies must be here.
 *
 * @param int $amount
 *   Payment amount.
 * @param string $currency
 *   Currency code.
 *
 * @return int
 *   Updated amount.
 */
function commerce_adyen_amount($amount, $currency) {
  switch ($currency) {
    // Adyen documentation says that the "Hungarian Forint" currency consists
    // of 2 decimal places. But the currency doesn't support decimal places.
    // So we need to multiply the sum by 100 for the correct data transfer.
    case 'HUF':
      $amount *= 100;
      break;
  }

  return $amount;
}

/**
 * Instantiate payment controller.
 *
 * @param string $controller
 *   One of controller types: "payment" or "checkout".
 * @param string $payment_type
 *   One of payment type names.
 * @param array $settings
 *   Payment method settings.
 * @param array[] $payment_types
 *   List of payment types. Must be result of "commerce_adyen_payment_types()".
 *
 * @return Payment|Checkout|null
 *   NULL if payment type class cannot be instantiated.
 */
function commerce_adyen_invoke_controller($controller, $payment_type, array $settings = NULL, array $payment_types = NULL) {
  if (NULL === $payment_types) {
    $payment_types = commerce_adyen_payment_types();
  }

  if (!isset($payment_types[$payment_type]['controllers'][$controller])) {
    return NULL;
  }

  if (NULL === $settings) {
    $settings = commerce_payment_method_instance_load(COMMERCE_ADYEN_PAYMENT_METHOD_INSTANCE)['settings'];
  }

  return new $payment_types[$payment_type]['controllers'][$controller](
    isset($settings['payment_types'][$payment_type]) ? $settings['payment_types'][$payment_type] : []
  );
}
