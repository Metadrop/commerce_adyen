<?php
/**
 * @file
 * Commerce Adyen.
 */

/**
 * Name of payment method.
 */
define('COMMERCE_ADYEN_PAYMENT_METHOD', 'commerce_adyen');
/**
 * URL to send notifications to.
 */
define('COMMERCE_ADYEN_NOTIFICATION_URL', 'commerce/adyen/notification');
/**
 * Name of instances of payment method.
 */
define('COMMERCE_ADYEN_PAYMENT_METHOD_INSTANCE', sprintf('%s|commerce_payment_%1$s', COMMERCE_ADYEN_PAYMENT_METHOD));
/**
 * Drupal payment status. Do not mix up with "remote_status"!
 */
define('COMMERCE_ADYEN_PAYMENT_STATUS_AUTHORISED', 'authorised');
/**
 * Remote status of a payment. Money has been captured.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_CAPTURED', 'captured');
/**
 * Remote status of a payment. Payment authorised on Adyen side.
 */
define('COMMERCE_ADYEN_PAYMENT_REMOTE_STATUS_AUTHORISED', 'authorised');

use Commerce\Adyen\Payment;

/**
 * Implements hook_menu().
 */
function commerce_adyen_menu() {
  $info = [];

  $info[COMMERCE_ADYEN_NOTIFICATION_URL] = [
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_adyen.notification.inc',
    'page callback' => 'commerce_adyen_notification',
    'access callback' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_adyen_commerce_payment_method_info() {
  $info = [];

  $info[COMMERCE_ADYEN_PAYMENT_METHOD] = [
    'file' => 'includes/commerce_adyen.payment.inc',
    'title' => 'Adyen',
    'description' => t('Redirect users to submit payments through Adyen.'),
    'active' => TRUE,
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_commerce_payment_transaction_status_info().
 */
function commerce_adyen_commerce_payment_transaction_status_info() {
  $module_path = drupal_get_path('module', 'commerce_adyen');
  $info = [];

  foreach ([
    // Adyen have its own payment workflow: initially payment should get
    // the authorisation confirmation and only then capturing could be
    // done. This status must be set when Adyen responds to us.
    COMMERCE_ADYEN_PAYMENT_STATUS_AUTHORISED => [
      'title' => t('Authorised'),
      'total' => TRUE,
    ],
  ] as $status => $data) {
    $info[$status] = $data + [
      'status' => $status,
      'icon' => "$module_path/icons/$status.png",
    ];
  }

  return $info;
}

/**
 * Implements hook_commerce_payment_transaction_insert().
 *
 * @see commerce_payment_commerce_payment_transaction_insert()
 */
function commerce_adyen_commerce_payment_transaction_insert(\stdClass $transaction) {
  if ((new Payment\Transaction($transaction->order_id))->isAuthorised()) {
    // An authorised payment with Adyen needs to be treated as part of the order
    // total. So we need to check the balance and fire the paid in full event.
    // Invoke the commerce_payment hook, with a spoofed success status,
    // instead of duplicating code.
    $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;

    module_invoke('commerce_payment', 'commerce_payment_transaction_insert', $transaction);

    // Restore our custom transaction status.
    $transaction->status = COMMERCE_ADYEN_PAYMENT_STATUS_AUTHORISED;
  }
}

/**
 * Implements hook_commerce_payment_transaction_update().
 */
function commerce_adyen_commerce_payment_transaction_update(\stdClass $transaction) {
  commerce_adyen_commerce_payment_transaction_insert($transaction);
}

/**
 * Implements hook_commerce_adyen_notification().
 */
function commerce_adyen_commerce_adyen_notification($event_code, \stdClass $order, \stdClass $data) {
  switch ($event_code) {
    case Payment\Notification::AUTHORISATION:
      $transaction = new Payment\Transaction($order);

      if ($data->success) {
        if (!$transaction->isAuthorised()) {
          $transaction->authorise($data->pspReference);
          commerce_payment_redirect_pane_next_page($order);
        }
      }
      else {
        $transaction->fail($data->pspReference);
        commerce_payment_redirect_pane_previous_page($order);
      }
      break;

    case Payment\Notification::CAPTURE:
      $transaction = new Payment\Transaction($order);

      if ($data->success && !$transaction->isFinalized()) {
        $transaction->finalize();
      }
      break;

    case Payment\Notification::CAPTURE_FAILED:
      // @todo What should be implemented here?
      break;

    case Payment\Notification::CANCELLATION:
      $transaction = new Payment\Transaction($order);
      $transaction->fail($data->pspReference);

      commerce_order_status_update($order, 'canceled');
      break;
  }

  if (isset($transaction)) {
    $transaction->setPayload($data);
    $transaction->save();
  }
}

/**
 * Get payment type definitions.
 *
 * @return array[]
 *   Payment type definitions.
 *
 * @see hook_commerce_adyen_payment_types()
 */
function commerce_adyen_payment_types() {
  $payment_types = [];

  $add_payment_type = function ($name, array $payment_type) use (&$payment_types) {
    try {
      if (!isset($payment_type['label'])) {
        throw new \InvalidArgumentException(t('Adyen payment type definition must have a label.'));
      }

      if (!isset($payment_type['controllers']['payment'])) {
        throw new \InvalidArgumentException(t('Adyen payment type must have definition of payment controller.'));
      }

      if (!is_subclass_of($payment_type['controllers']['payment'], Payment\Controller\Payment::class)) {
        throw new \InvalidArgumentException(t('Adyen payment type controller must be inherited from %class.', [
          '%class' => Payment\Controller\Payment::class,
        ]));
      }

      if (isset($payment_type['controllers']['checkout']) && !is_subclass_of($payment_type['controllers']['checkout'], Payment\Controller\Checkout::class)) {
        throw new \InvalidArgumentException(t('Adyen payment checkout controller must be inherited from %class.', [
          '%class' => Payment\Controller\Checkout::class,
        ]));
      }

      $payment_types[$name] = $payment_type;
    }
    catch (\InvalidArgumentException $e) {
      watchdog_exception(COMMERCE_ADYEN_PAYMENT_METHOD, $e);
    }
  };

  // Collect payment types.
  foreach (module_invoke_all(__FUNCTION__) as $name => $data) {
    $add_payment_type($name, $data);
  }

  // Allow other modules to alter the implementations.
  drupal_alter(__FUNCTION__, $payment_types);

  // Validate payment types after alteration.
  foreach ($payment_types as $name => $data) {
    $add_payment_type($name, $data);
  }

  return $payment_types;
}

/**
 * Process an amount due to strange behavior regarding some currencies.
 *
 * This function must be called for every price amount and all logic
 * for processing currencies must be here.
 *
 * @param int $amount
 *   Payment amount.
 * @param string $currency
 *   Currency code.
 *
 * @return int
 *   Updated amount.
 */
function commerce_adyen_amount($amount, $currency) {
  switch ($currency) {
    // Adyen documentation says that the "Hungarian Forint" currency consists
    // of 2 decimal places. But the currency doesn't support decimal places.
    // So we need to multiply the sum by 100 for the correct data transfer.
    case 'HUF':
      $amount *= 100;
      break;
  }

  return $amount;
}
